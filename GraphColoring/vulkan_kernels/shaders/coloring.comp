#version 460

layout(set = 0, binding = 0) buffer InAoBuffer {
    int Ao[];
};

layout(set = 0, binding = 1) buffer InAcBuffer {
    int Ac[];
};

layout(set = 0, binding = 2) buffer InRandomBuffer {
    int randoms[];
};

layout(set = 0, binding = 3) buffer InOutColors {
    int colors[];
};

layout(set = 0, binding = 4) buffer OutFinished {
    int finished[];
};

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    int current_color;
} push;

layout(constant_id = 0) const uint xSize = 0;
layout(constant_id = 1) const uint first = 0;
layout(constant_id = 2) const uint last = 0;

bvec4 color_jpl_ignore_neighbor(in const int c, in uint i, in const uvec4 j, in const vec4 jc)
{
    return bvec4(
        (int(jc.x != -1) & int(jc.x != c) & int(jc.x != c + 1)) | int(i == j.x),
        (int(jc.y != -1) & int(jc.y != c) & int(jc.y != c + 1)) | int(i == j.y),
        (int(jc.z != -1) & int(jc.z != c) & int(jc.z != c + 1)) | int(i == j.z),
        (int(jc.w != -1) & int(jc.w != c) & int(jc.w != c + 1)) | int(i == j.w)
        );
}

bool color_jpl_assign_color(in const int color, in const uint index, in const ivec2 local_max_min_color)
{
    const ivec2 color_choice = ivec2(colors[index], ((color + 1) * local_max_min_color.y + color * local_max_min_color.x) / (local_max_min_color.x + local_max_min_color.y));
    const bool idx = bool(local_max_min_color.x + local_max_min_color.y);
    colors[index] = color_choice[int(idx)];
    return idx;
}

void main()
{
    bool local_finished = true;
    int current_color = push.current_color;
    for (uint index = gl_GlobalInvocationID.y * xSize + gl_GlobalInvocationID.x; index < last - first; index += xSize) {
        if (colors[index] != -1) break;
        current_color *= 2;
        ivec2 local_max_min = ivec2(1, 1);
        const ivec3 base_current_next = ivec3(Ao[0], Ao[index], Ao[index + 1]);

        for (int k = base_current_next.y; k < base_current_next.z; k += 4) {
            uvec4 j = uvec4(Ac[k - base_current_next.x], Ac[k - base_current_next.x + 1], Ac[k - base_current_next.x + 2], Ac[k - base_current_next.x + 3]) - first;
            ivec4 current_colors = ivec4(colors[j.x], colors[j.y], colors[j.z], colors[j.w]);
            bvec4 ignore = color_jpl_ignore_neighbor(current_color, index, j, current_colors);

            ivec2 i_jr[4];
            const int index_shift = 4;
            for (int i = 0; i < 4; i++) {
                i_jr[i] = ivec2(randoms[(index + (current_color << index_shift)) % (last - first)], randoms[(j[i] + (current_color << index_shift)) % (last - first)]);
            }
            for (int i = 0; i < 4; i++) {
                //if (k + i >= base_current_next.z) break;
                if (int(j[i] < 0) + int(j[i] >= last - first) + int(ignore[i]) == 0) {
                    local_max_min = local_max_min * ivec2(int(i_jr[i].x > i_jr[i].y), int(i_jr[i].x < i_jr[i].y));
                }
            }
        }

        local_finished = local_finished && color_jpl_assign_color(current_color, index, local_max_min);
    }

    if (!local_finished) {
        finished[0] = 0;
    }
}
